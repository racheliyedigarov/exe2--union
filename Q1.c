#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#define SizeYear 6typedef union{	char hebrew[SizeYear];	int Gregorian;}year;typedef struct{	long unsigned id;	char* name;	int nameSize;	long unsigned salary;	year first;	int yearChoise;}Worker;typedef struct WorkerList{	Worker* data;	struct WorkerList* next;}WorkerList;Worker* CreatWorker(int choise);void PrintWorker(Worker* s, int choise);WorkerList* addWorker(WorkerList* head, Worker* w);int index(WorkerList* head, long unsigned id);int indexRec(WorkerList* head, long unsigned id);WorkerList* deleteWorstWorker(WorkerList* head);void update_worker(WorkerList* head, float precent);WorkerList* revers(WorkerList* head);void freeWorkers(WorkerList* head);void main(){	puts("what would you want to do?");	puts("A-add worker\nB-find a worker and print his card\nC-delete the worst worker\nD - raise the workerws sallary\nE - reverse the worker's list\nFdelete the list\nG-nothing");		char choice;	scanf(" %c", &choice);	int i = 0;	WorkerList * head = (WorkerList*)calloc(sizeof(WorkerList));	while (choice != 'G')	{		switch (choice)		{						{			int year;			puts("enter your choise: year of start\n1-hebrew year\n0-Gregorian year");			scanf(" %d", &year);			Worker * worker = CreatWorker(year);			head = addWorker(head, worker);			break;				}								{				printf("Enter id of the worker you want to find: ");				long unsigned idworker;				scanf(" %d", &idworker);				int place = index(head, idworker);				WorkerList* temp = head;				for (int i = 1; i < place; i++)				temp = temp->next;				PrintWorker(temp, temp->data->yearChoise);				break;				}									{				deleteWorstWorker(head);				break;				}		case 'D':				{					printf("enter the raise you want to do (in precent):");					float num;					scanf(" %f", &num);					update_worker(head, num);					break;				}		case 'E':		{			head = revers(head);			break;		}		case 'F':		{			freeWorkers(head);			break;		}		default:		{			puts("please enter one of the options");		}		break;		}		puts("would you like to do something else? enter your choise");		scanf(" %c", &choice);	}}Worker* CreatWorker(int choise){	Worker* neworkerPtr = (Worker*)calloc(sizeof(Worker));	if (!neworkerPtr)	{		printf("error");		exit(1);	}	puts("enter id:");	scanf(" %lu", &neworkerPtr->id);	char temp[100];	puts("\nenter name:");	fseek(stdin, 0, SEEK_END);	gets(temp);	neworkerPtr->nameSize = strlen(temp);	neworkerPtr->name = (char*)malloc(sizeof(char) * neworkerPtr->nameSize +		1);	if (!neworkerPtr->name)	{		printf("error");		exit(0);	}	strcpy(neworkerPtr->name, temp);	puts("\nenter salary:");	scanf(" %lu", &neworkerPtr->salary);		{	puts("\nenter hebrew year:");	fseek(stdin, 0, SEEK_END);	gets(&neworkerPtr->first);	}			{	puts("\nenter year:");	scanf(" %d", &neworkerPtr->first);	}	neworkerPtr->yearChoise = choise;	return neworkerPtr;}void PrintWorker(Worker* s, int choise){	puts("worker's name:");	printf("%s", s->name);	puts("\nworker's id:");	printf("%lu", s->id);	puts("\nworker's salary:");	printf("%lu", s->salary);	puts("\nworker's year of start:");//(choise (if		puts(s->first.hebrew);elseprintf("%d", s->first);}WorkerList* addWorker(WorkerList* head, Worker* w){	WorkerList* newList = (WorkerList*)calloc(1, sizeof(WorkerList));	if (head->data == NULL)// ריקה הרשימה אם	{		head->data = w;		return head;	}	newList->data = w;	 //(salary->w > salary->data->head (if			{	newList = w;	newList->next = head;	return newList;	}		if (head->data->salary < w->salary && head->next == NULL)// ברשימה שני מקום					{		head->next = newList;		return head;		}	WorkerList* prev = head;	WorkerList* temp = head->next;	while (temp->data->salary <= w->salary)// העובד של המיקום מציאת 	{		 // (NULL == next->temp (if		{		temp->next = newList;		return head;		}		temp = temp->next;		prev = prev->next;	}	prev->next = newList;	newList->next = temp;	return head;}int index(WorkerList* head, long unsigned id){	if (head == NULL)		return 0;	WorkerList* temp = head;	int res = 1;	while (temp->data->id != id)	{		 //(NULL = data->temp (if		{		printf("this worker is not in the workers list.");		return 0;		}		temp = temp->next;		res++;	}	return res;}int indexRec(WorkerList* head, long unsigned id)// רקורסיבית פונקציה{	 //(NULL == data->head (if	{	printf("this worker is not in the workers list.");	exit(1);	}		if (head->data->id = id)// עצירה תנאי			return 1;	return 1 + indexRec(head->next, id);}WorkerList* deleteWorstWorker(WorkerList* head){	if (head->data->salary < head->next->data->salary)// בעל הראשון שהעובד רשימה			{	WorkerList * temp = head;	free(head->data->name);	free(head->data);	head = temp->next;	}	else {		WorkerList* temp = head;		while (temp->next->next != NULL)			temp = temp->next;		free(temp->next->data->name);		free(temp->next->data);		temp->next = NULL;	}}void update_worker(WorkerList* head, float precent){	precent = (precent + 100) / 100;	WorkerList* temp = head;	while (temp->data != NULL)	{		temp->data->salary *= precent;		temp = temp->next;	}}WorkerList* revers(WorkerList* head){	if (head->data == NULL || head->next == NULL)// אחד איבר בעלת או ריקה רשימה		return head;		current = head;	prev = NULL;	while (current != NULL)	{		next = current->next;		current->next = prev;		prev = current;		current = next;	}	return prev;}void freeWorkers(WorkerList* head){	WorkerList* temp = head;	while (temp != NULL)	{		free(temp->data->name);		free(temp);		temp = temp->next;	}	free(head);